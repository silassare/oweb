import OWebEvent from './OWebEvent';
import { id } from './utils';
const eventHandlerMessage = '[OWebNet] Register event handler before calling send.';
export default class OWebNet extends OWebEvent {
    /**
     * OWebNet constructor.
     *
     * @param url
     * @param options
     * @protected
     */
    constructor(url, options) {
        super();
        this.url = url;
        this.options = options;
    }
    /**
     * Assertion that throws error when request is already sent.
     *
     * @param message
     * @private
     */
    assertNotSent(message) {
        if (this.isSent()) {
            throw Error(message);
        }
    }
    /**
     * Called when request sent and the server responded.
     *
     * @param handler
     */
    onResponse(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_RESPONSE, handler);
    }
    /**
     * Called when request sent and http response status code is in success range.
     *
     * @param handler
     */
    onHttpSuccess(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_HTTP_SUCCESS, handler);
    }
    /**
     * Always called when the request finished.
     *
     * @param handler
     */
    onFinish(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_FINISH, handler);
    }
    /**
     * Called when `options.responseType` is `json` and `options.isGoodNews` returns `true`.
     *
     * @param handler
     */
    onGoodNews(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_GOOD_NEWS, handler);
    }
    /**
     * Called when `options.responseType` is `json` and `options.isGoodNews` returns `false`.
     *
     * @param handler
     */
    onBadNews(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_BAD_NEWS, handler);
    }
    /**
     * Called on error: abort, timeout, network
     *
     * @param handler
     */
    onError(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_ERROR, handler);
    }
    /**
     * Called when request sent and http response status code is in error range.
     *
     * @param handler
     */
    onHttpError(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_HTTP_ERROR, handler);
    }
    /**
     * Called when there is a general error, an http status error or a bad news.
     *
     * @param handler
     */
    onFail(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_FAIL, handler);
    }
    /**
     * Listen to download progress event.
     *
     * NOTE: this is not supported by all browser.
     *
     * @param handler
     */
    onUploadProgress(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_UPLOAD_PROGRESS, handler);
    }
    /**
     * Listen to download progress event.
     *
     * @param handler
     */
    onDownloadProgress(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_DOWNLOAD_PROGRESS, handler);
    }
}
OWebNet.SELF = id();
OWebNet.EVT_ERROR = id(); // on error: abort, timeout, network
OWebNet.EVT_RESPONSE = id(); // request sent and the server responded.
OWebNet.EVT_HTTP_SUCCESS = id(); // request sent and http response status code is in success range
OWebNet.EVT_HTTP_ERROR = id(); // request sent and http response status code is not in success range
OWebNet.EVT_FINISH = id(); // request finished
OWebNet.EVT_GOOD_NEWS = id(); // the response is a good news [depends on provided options]
OWebNet.EVT_BAD_NEWS = id(); // the response is a bad news [depends on provided options]
OWebNet.EVT_FAIL = id(); // the request failed: there is a general error, an http status error or a bad news
OWebNet.EVT_UPLOAD_PROGRESS = id(); // on upload progress
OWebNet.EVT_DOWNLOAD_PROGRESS = id(); // on download progress
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT1dlYk5ldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9PV2ViTmV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxNQUFNLGFBQWEsQ0FBQztBQUNwQyxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBeUQzQixNQUFNLG1CQUFtQixHQUFHLHVEQUF1RCxDQUFDO0FBRXBGLE1BQU0sQ0FBQyxPQUFPLE9BQWdCLE9BQThCLFNBQVEsU0FBUztJQWE1RTs7Ozs7O09BTUc7SUFDSCxZQUNXLEdBQVcsRUFDWCxPQUE4QjtRQUV4QyxLQUFLLEVBQUUsQ0FBQztRQUhFLFFBQUcsR0FBSCxHQUFHLENBQVE7UUFDWCxZQUFPLEdBQVAsT0FBTyxDQUF1QjtJQUd6QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDTyxhQUFhLENBQUMsT0FBZTtRQUN0QyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUNsQixNQUFNLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNyQjtJQUNGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsVUFBVSxDQUFDLE9BQXdEO1FBQ2xFLElBQUksQ0FBQyxhQUFhLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUN4QyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGFBQWEsQ0FDWixPQUF3RDtRQUV4RCxJQUFJLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDeEMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFFBQVEsQ0FBQyxPQUE2QjtRQUNyQyxJQUFJLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDeEMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsT0FBd0Q7UUFDbEUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUyxDQUFDLE9BQTBEO1FBQ25FLElBQUksQ0FBQyxhQUFhLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUN4QyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE9BQU8sQ0FBQyxPQUErQztRQUN0RCxJQUFJLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDeEMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxXQUFXLENBQ1YsT0FBd0Q7UUFFeEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLE9BQWdEO1FBQ3RELElBQUksQ0FBQyxhQUFhLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUN4QyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsZ0JBQWdCLENBQ2YsT0FBc0Q7UUFFdEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxrQkFBa0IsQ0FDakIsT0FBc0Q7UUFFdEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMscUJBQXFCLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDeEQsQ0FBQzs7QUFsSmUsWUFBSSxHQUFvQixFQUFFLEVBQUUsQ0FBQztBQUM3QixpQkFBUyxHQUFlLEVBQUUsRUFBRSxDQUFDLENBQUMsb0NBQW9DO0FBQ2xFLG9CQUFZLEdBQVksRUFBRSxFQUFFLENBQUMsQ0FBQyx5Q0FBeUM7QUFDdkUsd0JBQWdCLEdBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxpRUFBaUU7QUFDL0Ysc0JBQWMsR0FBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDLHFFQUFxRTtBQUNuRyxrQkFBVSxHQUFjLEVBQUUsRUFBRSxDQUFDLENBQUMsbUJBQW1CO0FBQ2pELHFCQUFhLEdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyw0REFBNEQ7QUFDMUYsb0JBQVksR0FBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDLDJEQUEyRDtBQUN6RixnQkFBUSxHQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDLG1GQUFtRjtBQUNqSCwyQkFBbUIsR0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLHFCQUFxQjtBQUNuRCw2QkFBcUIsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPV2ViRXZlbnQgZnJvbSAnLi9PV2ViRXZlbnQnO1xuaW1wb3J0IHtpZH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge09WaWV3RGlhbG9nfSBmcm9tICcuL09XZWJWaWV3JztcblxuZXhwb3J0IHR5cGUgT05ldFJlcXVlc3RCb2R5ID1cblx0fCB1bmRlZmluZWRcblx0fCBzdHJpbmdcblx0fCBvYmplY3Rcblx0fCBGb3JtRGF0YVxuXHR8IFVSTFNlYXJjaFBhcmFtc1xuXHR8IEZpbGVcblx0fCBCbG9iO1xuXG5leHBvcnQgdHlwZSBPTmV0UmVxdWVzdFBhcmFtcyA9IHVuZGVmaW5lZCB8IG9iamVjdCB8IFVSTFNlYXJjaFBhcmFtcztcblxuZXhwb3J0IHR5cGUgT05ldFJlcXVlc3RNZXRob2QgPVxuXHR8ICdnZXQnXG5cdHwgJ0dFVCdcblx0fCAnZGVsZXRlJ1xuXHR8ICdERUxFVEUnXG5cdHwgJ2hlYWQnXG5cdHwgJ0hFQUQnXG5cdHwgJ29wdGlvbnMnXG5cdHwgJ09QVElPTlMnXG5cdHwgJ3Bvc3QnXG5cdHwgJ1BPU1QnXG5cdHwgJ3B1dCdcblx0fCAnUFVUJ1xuXHR8ICdwYXRjaCdcblx0fCAnUEFUQ0gnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9OZXRSZXNwb25zZTxUIGV4dGVuZHMgYW55PiB7XG5cdHJhdzogYW55O1xuXHRqc29uOiBUO1xuXHRzdGF0dXM6IG51bWJlcjtcblx0c3RhdHVzVGV4dDogc3RyaW5nO1xuXHRpc0dvb2ROZXdzOiBib29sZWFuO1xuXHRpc1N1Y2Nlc3NTdGF0dXM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT05ldEVycm9yIGV4dGVuZHMgT1ZpZXdEaWFsb2cge1xuXHR0eXBlOiAnZXJyb3InO1xuXHRlcnJUeXBlOiAnYmFkX25ld3MnIHwgJ2h0dHAnIHwgJ25ldHdvcmsnIHwgJ2Fib3J0JyB8ICd0aW1lb3V0JyB8ICd1bmtub3duJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPTmV0UmVxdWVzdE9wdGlvbnM8VCBleHRlbmRzIGFueT4ge1xuXHRtZXRob2Q6IE9OZXRSZXF1ZXN0TWV0aG9kO1xuXHRib2R5PzogT05ldFJlcXVlc3RCb2R5O1xuXHRwYXJhbXM/OiBPTmV0UmVxdWVzdFBhcmFtcztcblx0dGltZW91dDogbnVtYmVyO1xuXHR3aXRoQ3JlZGVudGlhbHM6IGJvb2xlYW47XG5cdHJlc3BvbnNlVHlwZTogWE1MSHR0cFJlcXVlc3RSZXNwb25zZVR5cGU7XG5cdGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG5cdGlzU3VjY2Vzc1N0YXR1czogKHN0YXR1czogbnVtYmVyKSA9PiBib29sZWFuO1xuXHRpc0dvb2ROZXdzOiAoanNvbjogbnVsbCB8IFQpID0+IGJvb2xlYW47XG5cdHNlcnZlckVycm9ySW5mbzogKHJlc3BvbnNlOiBPTmV0UmVzcG9uc2U8VD4pID0+IHsgdGV4dDogc3RyaW5nOyBkYXRhPzoge30gfTtcbn1cblxuY29uc3QgZXZlbnRIYW5kbGVyTWVzc2FnZSA9ICdbT1dlYk5ldF0gUmVnaXN0ZXIgZXZlbnQgaGFuZGxlciBiZWZvcmUgY2FsbGluZyBzZW5kLic7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIE9XZWJOZXQ8VCBleHRlbmRzIGFueSA9IG51bGw+IGV4dGVuZHMgT1dlYkV2ZW50IHtcblx0c3RhdGljIHJlYWRvbmx5IFNFTEYgICAgICAgICAgICAgICAgICA9IGlkKCk7XG5cdHN0YXRpYyByZWFkb25seSBFVlRfRVJST1IgICAgICAgICAgICAgPSBpZCgpOyAvLyBvbiBlcnJvcjogYWJvcnQsIHRpbWVvdXQsIG5ldHdvcmtcblx0c3RhdGljIHJlYWRvbmx5IEVWVF9SRVNQT05TRSAgICAgICAgICA9IGlkKCk7IC8vIHJlcXVlc3Qgc2VudCBhbmQgdGhlIHNlcnZlciByZXNwb25kZWQuXG5cdHN0YXRpYyByZWFkb25seSBFVlRfSFRUUF9TVUNDRVNTICAgICAgPSBpZCgpOyAvLyByZXF1ZXN0IHNlbnQgYW5kIGh0dHAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaXMgaW4gc3VjY2VzcyByYW5nZVxuXHRzdGF0aWMgcmVhZG9ubHkgRVZUX0hUVFBfRVJST1IgICAgICAgID0gaWQoKTsgLy8gcmVxdWVzdCBzZW50IGFuZCBodHRwIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlzIG5vdCBpbiBzdWNjZXNzIHJhbmdlXG5cdHN0YXRpYyByZWFkb25seSBFVlRfRklOSVNIICAgICAgICAgICAgPSBpZCgpOyAvLyByZXF1ZXN0IGZpbmlzaGVkXG5cdHN0YXRpYyByZWFkb25seSBFVlRfR09PRF9ORVdTICAgICAgICAgPSBpZCgpOyAvLyB0aGUgcmVzcG9uc2UgaXMgYSBnb29kIG5ld3MgW2RlcGVuZHMgb24gcHJvdmlkZWQgb3B0aW9uc11cblx0c3RhdGljIHJlYWRvbmx5IEVWVF9CQURfTkVXUyAgICAgICAgICA9IGlkKCk7IC8vIHRoZSByZXNwb25zZSBpcyBhIGJhZCBuZXdzIFtkZXBlbmRzIG9uIHByb3ZpZGVkIG9wdGlvbnNdXG5cdHN0YXRpYyByZWFkb25seSBFVlRfRkFJTCAgICAgICAgICAgICAgPSBpZCgpOyAvLyB0aGUgcmVxdWVzdCBmYWlsZWQ6IHRoZXJlIGlzIGEgZ2VuZXJhbCBlcnJvciwgYW4gaHR0cCBzdGF0dXMgZXJyb3Igb3IgYSBiYWQgbmV3c1xuXHRzdGF0aWMgcmVhZG9ubHkgRVZUX1VQTE9BRF9QUk9HUkVTUyAgID0gaWQoKTsgLy8gb24gdXBsb2FkIHByb2dyZXNzXG5cdHN0YXRpYyByZWFkb25seSBFVlRfRE9XTkxPQURfUFJPR1JFU1MgPSBpZCgpOyAvLyBvbiBkb3dubG9hZCBwcm9ncmVzc1xuXG5cdC8qKlxuXHQgKiBPV2ViTmV0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0gdXJsXG5cdCAqIEBwYXJhbSBvcHRpb25zXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihcblx0XHRwcm90ZWN0ZWQgdXJsOiBzdHJpbmcsXG5cdFx0cHJvdGVjdGVkIG9wdGlvbnM6IE9OZXRSZXF1ZXN0T3B0aW9uczxUPixcblx0KSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBc3NlcnRpb24gdGhhdCB0aHJvd3MgZXJyb3Igd2hlbiByZXF1ZXN0IGlzIGFscmVhZHkgc2VudC5cblx0ICpcblx0ICogQHBhcmFtIG1lc3NhZ2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHByb3RlY3RlZCBhc3NlcnROb3RTZW50KG1lc3NhZ2U6IHN0cmluZykge1xuXHRcdGlmICh0aGlzLmlzU2VudCgpKSB7XG5cdFx0XHR0aHJvdyBFcnJvcihtZXNzYWdlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gcmVxdWVzdCBzZW50IGFuZCB0aGUgc2VydmVyIHJlc3BvbmRlZC5cblx0ICpcblx0ICogQHBhcmFtIGhhbmRsZXJcblx0ICovXG5cdG9uUmVzcG9uc2UoaGFuZGxlcjogKHRoaXM6IHRoaXMsIHJlc3BvbnNlOiBPTmV0UmVzcG9uc2U8VD4pID0+IHZvaWQpOiB0aGlzIHtcblx0XHR0aGlzLmFzc2VydE5vdFNlbnQoZXZlbnRIYW5kbGVyTWVzc2FnZSk7XG5cdFx0cmV0dXJuIHRoaXMub24oT1dlYk5ldC5FVlRfUkVTUE9OU0UsIGhhbmRsZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHJlcXVlc3Qgc2VudCBhbmQgaHR0cCByZXNwb25zZSBzdGF0dXMgY29kZSBpcyBpbiBzdWNjZXNzIHJhbmdlLlxuXHQgKlxuXHQgKiBAcGFyYW0gaGFuZGxlclxuXHQgKi9cblx0b25IdHRwU3VjY2Vzcyhcblx0XHRoYW5kbGVyOiAodGhpczogdGhpcywgcmVzcG9uc2U6IE9OZXRSZXNwb25zZTxUPikgPT4gdm9pZCxcblx0KTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX0hUVFBfU1VDQ0VTUywgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogQWx3YXlzIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IGZpbmlzaGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gaGFuZGxlclxuXHQgKi9cblx0b25GaW5pc2goaGFuZGxlcjogKHRoaXM6IHRoaXMpID0+IHZvaWQpOiB0aGlzIHtcblx0XHR0aGlzLmFzc2VydE5vdFNlbnQoZXZlbnRIYW5kbGVyTWVzc2FnZSk7XG5cdFx0cmV0dXJuIHRoaXMub24oT1dlYk5ldC5FVlRfRklOSVNILCBoYW5kbGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBgb3B0aW9ucy5yZXNwb25zZVR5cGVgIGlzIGBqc29uYCBhbmQgYG9wdGlvbnMuaXNHb29kTmV3c2AgcmV0dXJucyBgdHJ1ZWAuXG5cdCAqXG5cdCAqIEBwYXJhbSBoYW5kbGVyXG5cdCAqL1xuXHRvbkdvb2ROZXdzKGhhbmRsZXI6ICh0aGlzOiB0aGlzLCByZXNwb25zZTogT05ldFJlc3BvbnNlPFQ+KSA9PiB2b2lkKTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX0dPT0RfTkVXUywgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYG9wdGlvbnMucmVzcG9uc2VUeXBlYCBpcyBganNvbmAgYW5kIGBvcHRpb25zLmlzR29vZE5ld3NgIHJldHVybnMgYGZhbHNlYC5cblx0ICpcblx0ICogQHBhcmFtIGhhbmRsZXJcblx0ICovXG5cdG9uQmFkTmV3cyhoYW5kbGVyOiAodGhpczogdGhpcywgcmVzcG9uc2U6IE9OZXRSZXNwb25zZTxhbnk+KSA9PiB2b2lkKTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX0JBRF9ORVdTLCBoYW5kbGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgb24gZXJyb3I6IGFib3J0LCB0aW1lb3V0LCBuZXR3b3JrXG5cdCAqXG5cdCAqIEBwYXJhbSBoYW5kbGVyXG5cdCAqL1xuXHRvbkVycm9yKGhhbmRsZXI6ICh0aGlzOiB0aGlzLCBlcnJvcjogT05ldEVycm9yKSA9PiB2b2lkKTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX0VSUk9SLCBoYW5kbGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiByZXF1ZXN0IHNlbnQgYW5kIGh0dHAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgaXMgaW4gZXJyb3IgcmFuZ2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBoYW5kbGVyXG5cdCAqL1xuXHRvbkh0dHBFcnJvcihcblx0XHRoYW5kbGVyOiAodGhpczogdGhpcywgcmVzcG9uc2U6IE9OZXRSZXNwb25zZTxUPikgPT4gdm9pZCxcblx0KTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX0hUVFBfRVJST1IsIGhhbmRsZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgZ2VuZXJhbCBlcnJvciwgYW4gaHR0cCBzdGF0dXMgZXJyb3Igb3IgYSBiYWQgbmV3cy5cblx0ICpcblx0ICogQHBhcmFtIGhhbmRsZXJcblx0ICovXG5cdG9uRmFpbChoYW5kbGVyOiAodGhpczogdGhpcywgcmFpc29uOiBPTmV0RXJyb3IpID0+IHZvaWQpOiB0aGlzIHtcblx0XHR0aGlzLmFzc2VydE5vdFNlbnQoZXZlbnRIYW5kbGVyTWVzc2FnZSk7XG5cdFx0cmV0dXJuIHRoaXMub24oT1dlYk5ldC5FVlRfRkFJTCwgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVuIHRvIGRvd25sb2FkIHByb2dyZXNzIGV2ZW50LlxuXHQgKlxuXHQgKiBOT1RFOiB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSBoYW5kbGVyXG5cdCAqL1xuXHRvblVwbG9hZFByb2dyZXNzKFxuXHRcdGhhbmRsZXI6ICh0aGlzOiB0aGlzLCBwcm9ncmVzczogUHJvZ3Jlc3NFdmVudCkgPT4gdm9pZCxcblx0KTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX1VQTE9BRF9QUk9HUkVTUywgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVuIHRvIGRvd25sb2FkIHByb2dyZXNzIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gaGFuZGxlclxuXHQgKi9cblx0b25Eb3dubG9hZFByb2dyZXNzKFxuXHRcdGhhbmRsZXI6ICh0aGlzOiB0aGlzLCBwcm9ncmVzczogUHJvZ3Jlc3NFdmVudCkgPT4gdm9pZCxcblx0KTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX0RPV05MT0FEX1BST0dSRVNTLCBoYW5kbGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBzZW50LlxuXHQgKi9cblx0YWJzdHJhY3QgaXNTZW50KCk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFNlbmQgdGhlIHJlcXVlc3QgYW5kIHJldHVybiBhIHByb21pc2UuXG5cdCAqL1xuXHRhYnN0cmFjdCBzZW5kKCk6IFByb21pc2U8T05ldFJlc3BvbnNlPFQ+PjtcblxuXHQvKipcblx0ICogQWJvcnQgdGhlIHJlcXVlc3Rcblx0ICovXG5cdGFic3RyYWN0IGFib3J0KCk6IHRoaXM7XG59XG4iXX0=