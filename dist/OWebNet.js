import OWebEvent from './OWebEvent';
import { id } from './utils';
const eventHandlerMessage = '[OWebNet] Register event handler before calling send.';
export default class OWebNet extends OWebEvent {
    url;
    options;
    static SELF = id();
    static EVT_ERROR = id(); // on error: abort, timeout, network
    static EVT_RESPONSE = id(); // request sent and the server responded.
    static EVT_HTTP_SUCCESS = id(); // request sent and http response status code is in success range
    static EVT_HTTP_ERROR = id(); // request sent and http response status code is not in success range
    static EVT_FINISH = id(); // request finished
    static EVT_GOOD_NEWS = id(); // the response is a good news [depends on provided options]
    static EVT_BAD_NEWS = id(); // the response is a bad news [depends on provided options]
    static EVT_FAIL = id(); // the request failed: there is a general error, an http status error or a bad news
    static EVT_UPLOAD_PROGRESS = id(); // on upload progress
    static EVT_DOWNLOAD_PROGRESS = id(); // on download progress
    /**
     * OWebNet constructor.
     *
     * @param url
     * @param options
     * @protected
     */
    constructor(url, options) {
        super();
        this.url = url;
        this.options = options;
    }
    /**
     * Assertion that throws error when request is already sent.
     *
     * @param message
     * @private
     */
    assertNotSent(message) {
        if (this.isSent()) {
            throw Error(message);
        }
    }
    /**
     * Called when request sent and the server responded.
     *
     * @param handler
     */
    onResponse(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_RESPONSE, handler);
    }
    /**
     * Called when request sent and http response status code is in success range.
     *
     * @param handler
     */
    onHttpSuccess(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_HTTP_SUCCESS, handler);
    }
    /**
     * Always called when the request finished.
     *
     * @param handler
     */
    onFinish(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_FINISH, handler);
    }
    /**
     * Called when `options.responseType` is `json` and `options.isGoodNews` returns `true`.
     *
     * @param handler
     */
    onGoodNews(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_GOOD_NEWS, handler);
    }
    /**
     * Called when `options.responseType` is `json` and `options.isGoodNews` returns `false`.
     *
     * @param handler
     */
    onBadNews(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_BAD_NEWS, handler);
    }
    /**
     * Called on error: abort, timeout, network
     *
     * @param handler
     */
    onError(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_ERROR, handler);
    }
    /**
     * Called when request sent and http response status code is in error range.
     *
     * @param handler
     */
    onHttpError(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_HTTP_ERROR, handler);
    }
    /**
     * Called when there is a general error, an http status error or a bad news.
     *
     * @param handler
     */
    onFail(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_FAIL, handler);
    }
    /**
     * Listen to download progress event.
     *
     * NOTE: this is not supported by all browser.
     *
     * @param handler
     */
    onUploadProgress(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_UPLOAD_PROGRESS, handler);
    }
    /**
     * Listen to download progress event.
     *
     * @param handler
     */
    onDownloadProgress(handler) {
        this.assertNotSent(eventHandlerMessage);
        return this.on(OWebNet.EVT_DOWNLOAD_PROGRESS, handler);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT1dlYk5ldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9PV2ViTmV0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxNQUFNLGFBQWEsQ0FBQztBQUNwQyxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBK0Q3QixNQUFNLG1CQUFtQixHQUN4Qix1REFBdUQsQ0FBQztBQUV6RCxNQUFNLENBQUMsT0FBTyxPQUFnQixPQUFrQixTQUFRLFNBQVM7SUFxQnJEO0lBQ0E7SUFyQlgsTUFBTSxDQUFVLElBQUksR0FBRyxFQUFFLEVBQUUsQ0FBQztJQUM1QixNQUFNLENBQVUsU0FBUyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsb0NBQW9DO0lBQ3RFLE1BQU0sQ0FBVSxZQUFZLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyx5Q0FBeUM7SUFDOUUsTUFBTSxDQUFVLGdCQUFnQixHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsaUVBQWlFO0lBQzFHLE1BQU0sQ0FBVSxjQUFjLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxxRUFBcUU7SUFDNUcsTUFBTSxDQUFVLFVBQVUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLG1CQUFtQjtJQUN0RCxNQUFNLENBQVUsYUFBYSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsNERBQTREO0lBQ2xHLE1BQU0sQ0FBVSxZQUFZLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQywyREFBMkQ7SUFDaEcsTUFBTSxDQUFVLFFBQVEsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLG1GQUFtRjtJQUNwSCxNQUFNLENBQVUsbUJBQW1CLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxxQkFBcUI7SUFDakUsTUFBTSxDQUFVLHFCQUFxQixHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsdUJBQXVCO0lBRXJFOzs7Ozs7T0FNRztJQUNILFlBQ1csR0FBVyxFQUNYLE9BQThCO1FBRXhDLEtBQUssRUFB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XG5pbXBvcnQgeyBpZCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgT1ZpZXdEaWFsb2cgfSBmcm9tICcuL09XZWJWaWV3JztcblxuZXhwb3J0IHR5cGUgT05ldFJlcXVlc3RCb2R5ID1cblx0fCB1bmRlZmluZWRcblx0fCBzdHJpbmdcblx0fCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuXHR8IEZvcm1EYXRhXG5cdHwgVVJMU2VhcmNoUGFyYW1zXG5cdHwgRmlsZVxuXHR8IEJsb2I7XG5cbmV4cG9ydCB0eXBlIE9OZXRSZXF1ZXN0UGFyYW1zID1cblx0fCB1bmRlZmluZWRcblx0fCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuXHR8IFVSTFNlYXJjaFBhcmFtcztcblxuZXhwb3J0IHR5cGUgT05ldFJlcXVlc3RNZXRob2QgPVxuXHR8ICdnZXQnXG5cdHwgJ0dFVCdcblx0fCAnZGVsZXRlJ1xuXHR8ICdERUxFVEUnXG5cdHwgJ2hlYWQnXG5cdHwgJ0hFQUQnXG5cdHwgJ29wdGlvbnMnXG5cdHwgJ09QVElPTlMnXG5cdHwgJ3Bvc3QnXG5cdHwgJ1BPU1QnXG5cdHwgJ3B1dCdcblx0fCAnUFVUJ1xuXHR8ICdwYXRjaCdcblx0fCAnUEFUQ0gnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9OZXRSZXNwb25zZTxUPiB7XG5cdHJhdzogYW55O1xuXHRqc29uOiBUO1xuXHRzdGF0dXM6IG51bWJlcjtcblx0c3RhdHVzVGV4dDogc3RyaW5nO1xuXHRpc0dvb2ROZXdzOiBib29sZWFuO1xuXHRpc1N1Y2Nlc3NTdGF0dXM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT05ldEVycm9yIGV4dGVuZHMgT1ZpZXdEaWFsb2cge1xuXHR0eXBlOiAnZXJyb3InO1xuXHRlcnJUeXBlOiAnYmFkX25ld3MnIHwgJ2h0dHAnIHwgJ25ldHdvcmsnIHwgJ2Fib3J0JyB8ICd0aW1lb3V0JyB8ICd1bmtub3duJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPTmV0UmVxdWVzdE9wdGlvbnM8VD4ge1xuXHRtZXRob2Q6IE9OZXRSZXF1ZXN0TWV0aG9kO1xuXHRib2R5PzogT05ldFJlcXVlc3RCb2R5O1xuXHRwYXJhbXM/OiBPTmV0UmVxdWVzdFBhcmFtcztcblx0dGltZW91dDogbnVtYmVyO1xuXHR3aXRoQ3JlZGVudGlhbHM6IGJvb2xlYW47XG5cdHJlc3BvbnNlVHlwZTogWE1MSHR0cFJlcXVlc3RbJ3Jlc3BvbnNlVHlwZSddO1xuXHRoZWFkZXJzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXHRpc1N1Y2Nlc3NTdGF0dXM6IChzdGF0dXM6IG51bWJlcikgPT4gYm9vbGVhbjtcblx0aXNHb29kTmV3czogKGpzb246IG51bGwgfCBUKSA9PiBib29sZWFuO1xuXHRlcnJvclJlc3BvbnNlVG9EaWFsb2c6IChyZXNwb25zZTogT05ldFJlc3BvbnNlPFQ+KSA9PiB7XG5cdFx0dGV4dDogc3RyaW5nO1xuXHRcdGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblx0fTtcbn1cblxuY29uc3QgZXZlbnRIYW5kbGVyTWVzc2FnZSA9XG5cdCdbT1dlYk5ldF0gUmVnaXN0ZXIgZXZlbnQgaGFuZGxlciBiZWZvcmUgY2FsbGluZyBzZW5kLic7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIE9XZWJOZXQ8VCA9IG51bGw+IGV4dGVuZHMgT1dlYkV2ZW50IHtcblx0c3RhdGljIHJlYWRvbmx5IFNFTEYgPSBpZCgpO1xuXHRzdGF0aWMgcmVhZG9ubHkgRVZUX0VSUk9SID0gaWQoKTsgLy8gb24gZXJyb3I6IGFib3J0LCB0aW1lb3V0LCBuZXR3b3JrXG5cdHN0YXRpYyByZWFkb25seSBFVlRfUkVTUE9OU0UgPSBpZCgpOyAvLyByZXF1ZXN0IHNlbnQgYW5kIHRoZSBzZXJ2ZXIgcmVzcG9uZGVkLlxuXHRzdGF0aWMgcmVhZG9ubHkgRVZUX0hUVFBfU1VDQ0VTUyA9IGlkKCk7IC8vIHJlcXVlc3Qgc2VudCBhbmQgaHR0cCByZXNwb25zZSBzdGF0dXMgY29kZSBpcyBpbiBzdWNjZXNzIHJhbmdlXG5cdHN0YXRpYyByZWFkb25seSBFVlRfSFRUUF9FUlJPUiA9IGlkKCk7IC8vIHJlcXVlc3Qgc2VudCBhbmQgaHR0cCByZXNwb25zZSBzdGF0dXMgY29kZSBpcyBub3QgaW4gc3VjY2VzcyByYW5nZVxuXHRzdGF0aWMgcmVhZG9ubHkgRVZUX0ZJTklTSCA9IGlkKCk7IC8vIHJlcXVlc3QgZmluaXNoZWRcblx0c3RhdGljIHJlYWRvbmx5IEVWVF9HT09EX05FV1MgPSBpZCgpOyAvLyB0aGUgcmVzcG9uc2UgaXMgYSBnb29kIG5ld3MgW2RlcGVuZHMgb24gcHJvdmlkZWQgb3B0aW9uc11cblx0c3RhdGljIHJlYWRvbmx5IEVWVF9CQURfTkVXUyA9IGlkKCk7IC8vIHRoZSByZXNwb25zZSBpcyBhIGJhZCBuZXdzIFtkZXBlbmRzIG9uIHByb3ZpZGVkIG9wdGlvbnNdXG5cdHN0YXRpYyByZWFkb25seSBFVlRfRkFJTCA9IGlkKCk7IC8vIHRoZSByZXF1ZXN0IGZhaWxlZDogdGhlcmUgaXMgYSBnZW5lcmFsIGVycm9yLCBhbiBodHRwIHN0YXR1cyBlcnJvciBvciBhIGJhZCBuZXdzXG5cdHN0YXRpYyByZWFkb25seSBFVlRfVVBMT0FEX1BST0dSRVNTID0gaWQoKTsgLy8gb24gdXBsb2FkIHByb2dyZXNzXG5cdHN0YXRpYyByZWFkb25seSBFVlRfRE9XTkxPQURfUFJPR1JFU1MgPSBpZCgpOyAvLyBvbiBkb3dubG9hZCBwcm9ncmVzc1xuXG5cdC8qKlxuXHQgKiBPV2ViTmV0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0gdXJsXG5cdCAqIEBwYXJhbSBvcHRpb25zXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihcblx0XHRwcm90ZWN0ZWQgdXJsOiBzdHJpbmcsXG5cdFx0cHJvdGVjdGVkIG9wdGlvbnM6IE9OZXRSZXF1ZXN0T3B0aW9uczxUPlxuXHQpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFzc2VydGlvbiB0aGF0IHRocm93cyBlcnJvciB3aGVuIHJlcXVlc3QgaXMgYWxyZWFkeSBzZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gbWVzc2FnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cHJvdGVjdGVkIGFzc2VydE5vdFNlbnQobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG5cdFx0aWYgKHRoaXMuaXNTZW50KCkpIHtcblx0XHRcdHRocm93IEVycm9yKG1lc3NhZ2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiByZXF1ZXN0IHNlbnQgYW5kIHRoZSBzZXJ2ZXIgcmVzcG9uZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gaGFuZGxlclxuXHQgKi9cblx0b25SZXNwb25zZShoYW5kbGVyOiAodGhpczogdGhpcywgcmVzcG9uc2U6IE9OZXRSZXNwb25zZTxUPikgPT4gdm9pZCk6IHRoaXMge1xuXHRcdHRoaXMuYXNzZXJ0Tm90U2VudChldmVudEhhbmRsZXJNZXNzYWdlKTtcblx0XHRyZXR1cm4gdGhpcy5vbihPV2ViTmV0LkVWVF9SRVNQT05TRSwgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gcmVxdWVzdCBzZW50IGFuZCBodHRwIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlzIGluIHN1Y2Nlc3MgcmFuZ2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBoYW5kbGVyXG5cdCAqL1xuXHRvbkh0dHBTdWNjZXNzKFxuXHRcdGhhbmRsZXI6ICh0aGlzOiB0aGlzLCByZXNwb25zZTogT05ldFJlc3BvbnNlPFQ+KSA9PiB2b2lkXG5cdCk6IHRoaXMge1xuXHRcdHRoaXMuYXNzZXJ0Tm90U2VudChldmVudEhhbmRsZXJNZXNzYWdlKTtcblx0XHRyZXR1cm4gdGhpcy5vbihPV2ViTmV0LkVWVF9IVFRQX1NVQ0NFU1MsIGhhbmRsZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFsd2F5cyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBmaW5pc2hlZC5cblx0ICpcblx0ICogQHBhcmFtIGhhbmRsZXJcblx0ICovXG5cdG9uRmluaXNoKGhhbmRsZXI6ICh0aGlzOiB0aGlzKSA9PiB2b2lkKTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX0ZJTklTSCwgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYG9wdGlvbnMucmVzcG9uc2VUeXBlYCBpcyBganNvbmAgYW5kIGBvcHRpb25zLmlzR29vZE5ld3NgIHJldHVybnMgYHRydWVgLlxuXHQgKlxuXHQgKiBAcGFyYW0gaGFuZGxlclxuXHQgKi9cblx0b25Hb29kTmV3cyhoYW5kbGVyOiAodGhpczogdGhpcywgcmVzcG9uc2U6IE9OZXRSZXNwb25zZTxUPikgPT4gdm9pZCk6IHRoaXMge1xuXHRcdHRoaXMuYXNzZXJ0Tm90U2VudChldmVudEhhbmRsZXJNZXNzYWdlKTtcblx0XHRyZXR1cm4gdGhpcy5vbihPV2ViTmV0LkVWVF9HT09EX05FV1MsIGhhbmRsZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIGBvcHRpb25zLnJlc3BvbnNlVHlwZWAgaXMgYGpzb25gIGFuZCBgb3B0aW9ucy5pc0dvb2ROZXdzYCByZXR1cm5zIGBmYWxzZWAuXG5cdCAqXG5cdCAqIEBwYXJhbSBoYW5kbGVyXG5cdCAqL1xuXHRvbkJhZE5ld3MoaGFuZGxlcjogKHRoaXM6IHRoaXMsIHJlc3BvbnNlOiBPTmV0UmVzcG9uc2U8YW55PikgPT4gdm9pZCk6IHRoaXMge1xuXHRcdHRoaXMuYXNzZXJ0Tm90U2VudChldmVudEhhbmRsZXJNZXNzYWdlKTtcblx0XHRyZXR1cm4gdGhpcy5vbihPV2ViTmV0LkVWVF9CQURfTkVXUywgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIG9uIGVycm9yOiBhYm9ydCwgdGltZW91dCwgbmV0d29ya1xuXHQgKlxuXHQgKiBAcGFyYW0gaGFuZGxlclxuXHQgKi9cblx0b25FcnJvcihoYW5kbGVyOiAodGhpczogdGhpcywgZXJyb3I6IE9OZXRFcnJvcikgPT4gdm9pZCk6IHRoaXMge1xuXHRcdHRoaXMuYXNzZXJ0Tm90U2VudChldmVudEhhbmRsZXJNZXNzYWdlKTtcblx0XHRyZXR1cm4gdGhpcy5vbihPV2ViTmV0LkVWVF9FUlJPUiwgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gcmVxdWVzdCBzZW50IGFuZCBodHRwIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlzIGluIGVycm9yIHJhbmdlLlxuXHQgKlxuXHQgKiBAcGFyYW0gaGFuZGxlclxuXHQgKi9cblx0b25IdHRwRXJyb3IoaGFuZGxlcjogKHRoaXM6IHRoaXMsIHJlc3BvbnNlOiBPTmV0UmVzcG9uc2U8VD4pID0+IHZvaWQpOiB0aGlzIHtcblx0XHR0aGlzLmFzc2VydE5vdFNlbnQoZXZlbnRIYW5kbGVyTWVzc2FnZSk7XG5cdFx0cmV0dXJuIHRoaXMub24oT1dlYk5ldC5FVlRfSFRUUF9FUlJPUiwgaGFuZGxlcik7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBnZW5lcmFsIGVycm9yLCBhbiBodHRwIHN0YXR1cyBlcnJvciBvciBhIGJhZCBuZXdzLlxuXHQgKlxuXHQgKiBAcGFyYW0gaGFuZGxlclxuXHQgKi9cblx0b25GYWlsKGhhbmRsZXI6ICh0aGlzOiB0aGlzLCByYWlzb246IE9OZXRFcnJvcikgPT4gdm9pZCk6IHRoaXMge1xuXHRcdHRoaXMuYXNzZXJ0Tm90U2VudChldmVudEhhbmRsZXJNZXNzYWdlKTtcblx0XHRyZXR1cm4gdGhpcy5vbihPV2ViTmV0LkVWVF9GQUlMLCBoYW5kbGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaXN0ZW4gdG8gZG93bmxvYWQgcHJvZ3Jlc3MgZXZlbnQuXG5cdCAqXG5cdCAqIE5PVEU6IHRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBhbGwgYnJvd3Nlci5cblx0ICpcblx0ICogQHBhcmFtIGhhbmRsZXJcblx0ICovXG5cdG9uVXBsb2FkUHJvZ3Jlc3MoXG5cdFx0aGFuZGxlcjogKHRoaXM6IHRoaXMsIHByb2dyZXNzOiBQcm9ncmVzc0V2ZW50KSA9PiB2b2lkXG5cdCk6IHRoaXMge1xuXHRcdHRoaXMuYXNzZXJ0Tm90U2VudChldmVudEhhbmRsZXJNZXNzYWdlKTtcblx0XHRyZXR1cm4gdGhpcy5vbihPV2ViTmV0LkVWVF9VUExPQURfUFJPR1JFU1MsIGhhbmRsZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbiB0byBkb3dubG9hZCBwcm9ncmVzcyBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIGhhbmRsZXJcblx0ICovXG5cdG9uRG93bmxvYWRQcm9ncmVzcyhcblx0XHRoYW5kbGVyOiAodGhpczogdGhpcywgcHJvZ3Jlc3M6IFByb2dyZXNzRXZlbnQpID0+IHZvaWRcblx0KTogdGhpcyB7XG5cdFx0dGhpcy5hc3NlcnROb3RTZW50KGV2ZW50SGFuZGxlck1lc3NhZ2UpO1xuXHRcdHJldHVybiB0aGlzLm9uKE9XZWJOZXQuRVZUX0RPV05MT0FEX1BST0dSRVNTLCBoYW5kbGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBzZW50LlxuXHQgKi9cblx0YWJzdHJhY3QgaXNTZW50KCk6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIFNlbmQgdGhlIHJlcXVlc3QgYW5kIHJldHVybiBhIHByb21pc2UuXG5cdCAqL1xuXHRhYnN0cmFjdCBzZW5kKCk6IFByb21pc2U8T05ldFJlc3BvbnNlPFQ+PjtcblxuXHQvKipcblx0ICogQWJvcnQgdGhlIHJlcXVlc3Rcblx0ICovXG5cdGFic3RyYWN0IGFib3J0KCk6IHRoaXM7XG59XG4iXX0=